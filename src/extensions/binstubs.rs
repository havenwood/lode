//! Generate wrapper scripts for gem executables.

use anyhow::{Context, Result};
use std::fs;
use std::path::{Path, PathBuf};

/// Binstub generator
///
/// Generates wrapper scripts for gem executables (similar to `bundle binstubs`).
#[derive(Debug)]
pub struct BinstubGenerator {
    /// Directory where binstubs will be created (e.g., vendor/bundle/bin)
    bin_dir: PathBuf,
    /// Path to Gemfile (for `BUNDLE_GEMFILE`)
    gemfile_path: PathBuf,
    /// Custom shebang line (defaults to `#!/usr/bin/env ruby`)
    shebang: Option<String>,
    /// Overwrite existing binstubs
    force: bool,
}

impl BinstubGenerator {
    /// Create a new binstub generator.
    #[must_use]
    pub const fn new(
        bin_dir: PathBuf,
        gemfile_path: PathBuf,
        shebang: Option<String>,
        force: bool,
    ) -> Self {
        Self {
            bin_dir,
            gemfile_path,
            shebang,
            force,
        }
    }

    /// Generate binstubs for a gem
    ///
    /// # Arguments
    /// * `gem_name` - Name of the gem
    /// * `gem_dir` - Directory containing the installed gem
    ///
    /// # Returns
    /// Number of binstubs created
    pub fn generate(&self, gem_name: &str, gem_dir: &Path) -> Result<usize> {
        // Find executables in gem
        let executables = Self::find_executables(gem_dir)?;

        if executables.is_empty() {
            return Ok(0);
        }

        // Create bin directory if needed
        fs::create_dir_all(&self.bin_dir).with_context(|| {
            format!("Failed to create bin directory: {}", self.bin_dir.display())
        })?;

        // Generate binstub for each executable
        let mut count = 0;
        for exe_name in &executables {
            self.create_binstub(exe_name, gem_name)?;
            count += 1;
        }

        Ok(count)
    }

    /// Find executables in a gem directory
    ///
    /// Looks in exe/ (modern) and bin/ (legacy) directories.
    fn find_executables(gem_dir: &Path) -> Result<Vec<String>> {
        let mut executables = Vec::new();

        // Check exe/ directory (modern convention)
        let exe_dir = gem_dir.join("exe");
        if exe_dir.exists() && exe_dir.is_dir() {
            executables.extend(Self::scan_dir(&exe_dir)?);
        }

        // Check bin/ directory (legacy convention)
        let bin_dir = gem_dir.join("bin");
        if bin_dir.exists() && bin_dir.is_dir() {
            executables.extend(Self::scan_dir(&bin_dir)?);
        }

        Ok(executables)
    }

    /// Scan directory for executable files
    fn scan_dir(dir: &Path) -> Result<Vec<String>> {
        let mut executables = Vec::new();

        for entry in fs::read_dir(dir)
            .with_context(|| format!("Failed to read directory: {}", dir.display()))?
        {
            let entry = entry?;
            let path = entry.path();

            // Only include files without extensions (not directories)
            if path.is_file()
                && path.extension().is_none()
                && let Some(name) = path.file_name()
            {
                executables.push(name.to_string_lossy().to_string());
            }
        }

        Ok(executables)
    }

    /// Create a binstub wrapper script
    ///
    /// Generates the wrapper script that sets up Bundler and loads the gem's executable.
    fn create_binstub(&self, exe_name: &str, gem_name: &str) -> Result<()> {
        let binstub_path = self.bin_dir.join(exe_name);

        // Skip if file exists and not force mode
        if binstub_path.exists() && !self.force {
            return Ok(());
        }

        // Calculate relative path from bin_dir to Gemfile
        let relative_gemfile = Self::calculate_relative_path(&self.bin_dir, &self.gemfile_path);

        // Use custom shebang or default
        let shebang = self.shebang.as_deref().unwrap_or("#!/usr/bin/env ruby");

        // Generate binstub content
        let content = format!(
            r#"{shebang}
# Generated by Lode
# This file makes it easy to run this gem's executable without
# activating all of Bundler's dependencies. It loads only this gem.

ENV['BUNDLE_GEMFILE'] ||= File.expand_path('{relative_gemfile}', __dir__)

begin
  require 'bundler/setup'
rescue LoadError => e
  warn "Bundler is not available. Install it with: gem install bundler"
  raise e
end

load Gem.bin_path('{gem_name}', '{exe_name}')
"#
        );

        // Write binstub file
        fs::write(&binstub_path, content)
            .with_context(|| format!("Failed to write binstub: {}", binstub_path.display()))?;

        // Make executable on Unix
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let mut perms = fs::metadata(&binstub_path)?.permissions();
            perms.set_mode(0o755); // rwxr-xr-x
            fs::set_permissions(&binstub_path, perms)?;
        }

        Ok(())
    }

    /// Calculate relative path from one directory to a file
    ///
    /// Similar to Ruby's `File.expand_path('../Gemfile', __dir__)`
    fn calculate_relative_path(from_dir: &Path, to_file: &Path) -> String {
        // Try to canonicalize, but fall back to the original paths if files don't exist
        let from = if from_dir.exists() {
            fs::canonicalize(from_dir).unwrap_or_else(|_| from_dir.to_path_buf())
        } else {
            from_dir.to_path_buf()
        };

        let to = if to_file.exists() {
            fs::canonicalize(to_file).unwrap_or_else(|_| to_file.to_path_buf())
        } else {
            to_file.to_path_buf()
        };

        // Calculate relative path
        let mut from_components: Vec<_> = from.components().collect();
        let mut to_components: Vec<_> = to.components().collect();

        // Remove common prefix
        while let (Some(first_from), Some(first_to)) =
            (from_components.first(), to_components.first())
        {
            if first_from == first_to {
                from_components.remove(0);
                to_components.remove(0);
            } else {
                break;
            }
        }

        // Build relative path
        let mut result = Vec::new();

        // Add .. for each remaining directory in from_dir
        result.extend(std::iter::repeat_n("..", from_components.len()));

        // Add remaining components from to_file
        for component in &to_components {
            if let Some(s) = component.as_os_str().to_str() {
                result.push(s);
            }
        }

        result.join("/")
    }
}

/// Generate binstubs for multiple gems (convenience function)
///
/// Equivalent to running `bundle binstubs` for multiple gems at once.
///
/// # Example
///
/// ```no_run
/// use lode::extensions::generate_binstubs;
/// use std::path::Path;
///
/// let gems = vec![
///     ("rails", Path::new("vendor/gems/rails-7.0.8")),
///     ("rake", Path::new("vendor/gems/rake-13.0.6")),
/// ];
///
/// let bin_dir = Path::new("vendor/bundle/bin");
/// let gemfile = Path::new("Gemfile");
///
/// let count = generate_binstubs(&gems, bin_dir, gemfile).unwrap();
/// println!("Generated {} binstubs", count);
/// ```
pub fn generate_binstubs(
    gems: &[(&str, &Path)],
    bin_dir: &Path,
    gemfile_path: &Path,
) -> Result<usize> {
    let generator = BinstubGenerator::new(
        bin_dir.to_path_buf(),
        gemfile_path.to_path_buf(),
        None,
        false,
    );

    let mut total = 0;
    for (gem_name, gem_dir) in gems {
        let count = generator.generate(gem_name, gem_dir)?;
        total += count;
    }

    Ok(total)
}

#[cfg(test)]
#[allow(clippy::unwrap_used, reason = "Tests can panic")]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::TempDir;

    fn create_gem_with_executables(executables: &[&str]) -> TempDir {
        let dir = TempDir::new().unwrap();
        let exe_dir = dir.path().join("exe");

        fs::create_dir_all(&exe_dir).unwrap();

        for exe in executables {
            let exe_path = exe_dir.join(exe);
            fs::write(&exe_path, "#!/usr/bin/env ruby\nputs 'Hello'").unwrap();

            #[cfg(unix)]
            {
                use std::os::unix::fs::PermissionsExt;
                let mut perms = fs::metadata(&exe_path).unwrap().permissions();
                perms.set_mode(0o755);
                fs::set_permissions(&exe_path, perms).unwrap();
            }
        }

        dir
    }

    fn create_gem_without_executables() -> TempDir {
        let dir = TempDir::new().unwrap();
        let lib_dir = dir.path().join("lib");
        fs::create_dir_all(&lib_dir).unwrap();
        fs::write(lib_dir.join("test.rb"), "# Ruby code").unwrap();
        dir
    }

    #[test]
    fn generator_creation() {
        let bin_dir = PathBuf::from("/tmp/bin");
        let gemfile = PathBuf::from("/tmp/Gemfile");

        let generator = BinstubGenerator::new(bin_dir.clone(), gemfile.clone(), None, false);

        assert_eq!(generator.bin_dir, bin_dir);
        assert_eq!(generator.gemfile_path, gemfile);
    }

    #[test]
    fn test_find_executables() {
        let gem_dir = create_gem_with_executables(&["rails", "rake"]);

        let executables = BinstubGenerator::find_executables(gem_dir.path()).unwrap();

        assert_eq!(executables.len(), 2);
        assert!(executables.contains(&"rails".to_string()));
        assert!(executables.contains(&"rake".to_string()));
    }

    #[test]
    fn find_executables_empty() {
        let gem_dir = create_gem_without_executables();

        let executables = BinstubGenerator::find_executables(gem_dir.path()).unwrap();

        assert_eq!(executables.len(), 0);
    }

    #[test]
    fn test_generate_binstubs() {
        let gem_dir = create_gem_with_executables(&["rails", "rake"]);
        let bin_dir = TempDir::new().unwrap();
        let gemfile_dir = TempDir::new().unwrap();
        let gemfile = gemfile_dir.path().join("Gemfile");
        fs::write(&gemfile, "source 'https://rubygems.org'").unwrap();

        let generator = BinstubGenerator::new(bin_dir.path().to_path_buf(), gemfile, None, false);

        let count = generator.generate("test_gem", gem_dir.path()).unwrap();

        assert_eq!(count, 2);
        assert!(bin_dir.path().join("rails").exists());
        assert!(bin_dir.path().join("rake").exists());

        // Check content
        let content = fs::read_to_string(bin_dir.path().join("rails")).unwrap();
        assert!(content.contains("#!/usr/bin/env ruby"));
        assert!(content.contains("Generated by Lode"));
        assert!(content.contains("test_gem"));
        assert!(content.contains("rails"));
    }

    #[test]
    fn generate_no_executables() {
        let gem_dir = create_gem_without_executables();
        let bin_dir = TempDir::new().unwrap();
        let gemfile_dir = TempDir::new().unwrap();
        let gemfile = gemfile_dir.path().join("Gemfile");
        fs::write(&gemfile, "source 'https://rubygems.org'").unwrap();

        let generator = BinstubGenerator::new(bin_dir.path().to_path_buf(), gemfile, None, false);

        let count = generator.generate("test_gem", gem_dir.path()).unwrap();

        assert_eq!(count, 0);
    }

    #[test]
    #[cfg(unix)]
    fn test_binstub_is_executable() {
        use std::os::unix::fs::PermissionsExt;

        let gem_dir = create_gem_with_executables(&["test_exe"]);
        let bin_dir = TempDir::new().unwrap();
        let gemfile_dir = TempDir::new().unwrap();
        let gemfile = gemfile_dir.path().join("Gemfile");
        fs::write(&gemfile, "source 'https://rubygems.org'").unwrap();

        let generator = BinstubGenerator::new(bin_dir.path().to_path_buf(), gemfile, None, false);
        generator.generate("test_gem", gem_dir.path()).unwrap();

        let binstub_path = bin_dir.path().join("test_exe");
        let perms = fs::metadata(&binstub_path).unwrap().permissions();

        assert!(perms.mode() & 0o111 != 0, "Binstub should be executable");
    }

    #[test]
    fn test_calculate_relative_path() {
        let temp = TempDir::new().unwrap();
        let bin_dir = temp.path().join("vendor").join("bundle").join("bin");
        let gemfile = temp.path().join("Gemfile");

        fs::create_dir_all(&bin_dir).unwrap();
        fs::write(&gemfile, "").unwrap();

        let relative = BinstubGenerator::calculate_relative_path(&bin_dir, &gemfile);

        assert_eq!(relative, "../../../Gemfile");
    }
}
